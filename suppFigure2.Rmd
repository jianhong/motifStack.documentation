---
title: "Supplementary Figure 2"
output:
  pdf_document:
    fig_caption: yes
    toc: yes
    includes:
      in_header: header.tex
  html_document:
    fig_caption: yes
    self_contained: no
    toc: yes
---
```{r setup, include=FALSE}
fn = local({
  function(x, letter, auto=FALSE) {
    paste('__Supplementary Figure 2', letter, '__: ', x, sep = '')
  }
})
```

**Input Data**

```{r inputdata, message=FALSE, warning=FALSE, error=FALSE}
##load the library
library(motifStack)

##read pcms
pcmpath <- "pcmsDatasetDM"
pcms <- readPCM(pcmpath)
##convert to pfms
pfms<-lapply(pcms,pcm2pfm)
```

## Supplementary Figure 2A-D. Examples of linear and radial dendrograms and commands to generate Them

### Supplementary Figure 2A
```{r stackLayout, fig.width=6, fig.height=6, dpi=72, fig.cap=fn("plotted as a stack of motifs", "A")}
subset_pfms <- pfms[10:15]
motifStack(subset_pfms, layout="stack")
```

### Supplementary Figure 2B

```{r treeLayout, fig.width=6, fig.height=6, dpi=72, fig.cap=fn("plotted as a linear tree", "B")}
##By default, MotIV is used for clustering
motifStack(subset_pfms, layout="tree", trueDist=TRUE)
```

### Supplementary Figure 2C

```{r phylogLayout, fig.width=6, fig.height=6, dpi=72, fig.cap=fn("plotted as a linear phylogenic tree", "C")}
##try different style of sequence logo
motifStack(pfms[sample(1:length(pfms), 20)], layout="phylog", clabel.leaves=.8,
           f.logo=0.6, ic.scale=FALSE)
```

### Supplementary Figure 2D

```{r radialPhylogLayout, fig.width=10, fig.height=10, dpi=72, fig.cap=fn("plotted as a radial phylogenic tree", "D")}
##using Pearson Correleation Coefficient as Column comparison metric and Smith-Waterman Ungapped
motifStack(pfms, layout="radialPhylog")
```

## Supplementary Figure 2E-G. Merge motifs using motifSignature function with different distance cutoffs, and plot merged motifs in various layouts

Before motifs being merged, the distances of the motifs need to be calculated using STAMP, MovIV or MatAlign. Here we show how different distance cutoffs affect the merging results. The red dotted line indicates the distance cutoff used.

### Supplementary Figure 2E

```{r merging, fig.width=4, fig.height=4, fig.cap=fn("merging by different distance", "E")}
outpath <- "output"
matalign_path <- "./app/matalign-v4a"
neighbor_path <- "./app/neighbor.app/Contents/MacOS/neighbor"
pcmpath <- "pcmsDatasetDM"
pcms <- readPCM(pcmpath)
pfms<-lapply(pcms,pcm2pfm)
system(paste("perl MatAlign2tree.pl --in . --pcmpath", pcmpath, 
             "--out", outpath,
             "--matalign", matalign_path, 
             "--neighbor", neighbor_path, 
             "--tree","UPGMA"))
newickstrUPGMA <- readLines(con=file.path(outpath, "NJ.matalign.distMX.nwk"))
phylogUPGMAmatAlign <- newick2phylog(newickstrUPGMA, FALSE)
##get the leaves of phylog to reorder the pfms
matAlignLeaveNames <- names(phylogUPGMAmatAlign$leaves)
this_motifs <- pfms[matAlignLeaveNames]
matAlignLeaveNames <- gsub("^Dm_", "", matAlignLeaveNames)

for(groupDistance in c(0, 1, 2, 3)){
    motifSig <- motifSignature(this_motifs, 
                               phylogUPGMAmatAlign, 
                               groupDistance=groupDistance, 
                               min.freq=1)
    this_sig <- signatures(motifSig)
    ## get color set for signature groups
    this_gpCol <- sigColor(motifSig)
    plotMotifStackWithRadialPhylog(phylog=phylogUPGMAmatAlign, 
                                   pfms=this_sig,
                                   col.inner.label.circle=this_gpCol, 
                                   inner.label.circle.width=0.02, 
                                   labels.leaves=matAlignLeaveNames, 
                                   cleaves=.2, circle=1, circle.motif=1.5, 
                                   clabel.leaves=.4, motifScale="logarithmic", 
                                   angle=358, plotIndex=TRUE, IndexCex=.6, 
                                   groupDistance=groupDistance)
    text(0, 2.3, label=paste("group distance =", groupDistance), cex=2)
}
```


### Supplementary Figure 2F
```{r motifCloud, warning=FALSE, fig.width=3.5, fig.height=3.5, dpi=72, fig.cap=fn('motifCloud', "F")}
## get signature
gpDist <- c(.5, 1)
motifSig <- lapply(gpDist, motifSignature, 
                   pfms=this_motifs, 
                   phylog=phylogUPGMAmatAlign, 
                   min.freq=1)
## motif cloud, cloud style
for(i in 1:2){
    motifCloud(motifSig[[i]], layout="cloud", scale=c(9, .75))
    op <- par(mar = c(0, 0, 0, 0))
    text(.5, .985, label=paste("group distance =", gpDist[i]))
    par(op)
}
```

### Supplementary Figure 2G
```{r motifCloudRect, warning=FALSE, fig.width=3.5, fig.height=3.5, fig.cap=fn('motifCloud', "G")}
## motif cloud, rectangle style
for(i in 2:2){
    motifCloud(motifSig[[i]], layout="rectangles", ic.scale=FALSE)
    op <- par(mar = c(0, 0, 0, 0))
    text(.5, .985, label=paste("group distance =", gpDist[i]))
    par(op)
}
```

## Supplementary Figure 2H-M. Use various color options to visualize different sources of variations in the motif set

There are four ways to color a radial phylogenic tree, i.e., the background of the inner circle, the motif names, the inner label ring and the outer label ring. Here are a few examples on how to use these options to show the data source of the motif, the computational algorithm for generating the motifs, information content (IC) and the motif group. 

```{r functions}
##color sets
getPairColor <- function(n=10L){
    if(n %% 2 != 0) n <- n+1
    n <- n/2
    n <- rainbow(n)#as.character(t(matrix(rainbow(n=n), ncol=2, byrow=FALSE)))
    n2 <- highlightCol(n, .5)
    as.character(t(cbind(n, n2)))
}

pairColor <- getPairColor(22)

pfmList2matrixList <- function(pfms){
        m <- lapply(pfms, function(.ele) as(.ele, "matrix"))
        names(m) <- unlist(lapply(pfms, function(.ele) .ele@name))
        m
}
getMotIVOut <- function(pfms, cc, align){
    jaspar.scores <- 
        MotIV::readDBScores(
            file.path(".", "app", "scores", 
                      paste("JaspRand_", cc, "_", align, ".scores", sep="")))
    d <- MotIV::motifDistances(pfmList2matrixList(pfms), cc=cc, align=align)
    hc <- MotIV::motifHclust(d, method="average")
    phylog <- hclust2phylog(hc)
    pfms <- pfms[hc$order]
    aligned.pfms <- DNAmotifAlignment(pfms)
    leaveNames <-names(phylog$leaves)
    ## data source
    dataSource <- factor(grepl("_M", leaveNames))
    levels(dataSource) <- c("yellow", "blue") ##c("Uniprobe", "CIS-BP")
    dataSource <- as.character(dataSource)
    ## algorithm
    algorithm <- 
        factor((!grepl("_M", leaveNames)) + grepl("_bml", leaveNames))
    levels(algorithm) <- 
        c("blue", "brown", "orange") ##("DREAM5", "Seed-And-Wobble", "BEEML")
    algorithm <- as.character(algorithm)
    ## motifs from same PBM data
    motifGroup <- factor(gsub("(.*?)_.*$", "\\1", leaveNames))
    levels.motifGroup <- levels(motifGroup)
    levels(motifGroup) <- pairColor[1:length(levels(motifGroup))]
    colors.motifGroup <- levels(motifGroup)
    motifGroup <- as.character(motifGroup)
    return(list(aligned.pfms=aligned.pfms, unaligned.pfms=pfms, phylog=phylog, 
                leaveNames=leaveNames, 
                dataSource=dataSource,
                algorithm=algorithm,
                motifGroup=motifGroup,
                levels.motifGroup=levels.motifGroup,
                colors.motifGroup=colors.motifGroup))
}
##read pcms
pcmpath <- "pcmsDatasetAlgorithm"
pcms <- readPCM(pcmpath)
##convert to pfms
pfms<-lapply(pcms,pcm2pfm)
```

### Supplementary Figure 2H
```{r colorsets1, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("color setting, tree background", "H")}
motIVout <- getMotIVOut(pfms, "PCC", "SWU")
attach(motIVout)
plotMotifStackWithRadialPhylog(phylog=phylog, pfms=unaligned.pfms,
                            labels.leaves=leaveNames, 
                            col.bg=dataSource, col.bg.alpha=.3,
                            cleaves=.2, circle=1.1, circle.motif=1.6, 
                            clabel.leaves=.8, angle=358)
legend(-2.3, 2.4, legend=c("Uniprobe", "CIS-BP"), 
       fill= highlightCol(c("yellow", "blue"), alpha=.3), 
       border="white", lty=NULL, bty = "n", cex=1)
text(0, 2.4, "Use the color of the background of inner circle to distinguish different data sources with the parameter col.bg", cex=1.5)
```

### Supplementary Figure 2I
```{r colorsets2, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("color setting, leaves", "I")}
plotMotifStackWithRadialPhylog(phylog=phylog, pfms=unaligned.pfms,
                            labels.leaves=leaveNames, 
                            col.leaves=algorithm,
                            cleaves=.2, circle=1.1, circle.motif=1.6, 
                            clabel.leaves=.8, angle=358)
legend(-2.3, 2.4, legend=c("DREAM5", "Seed-And-Wobble", "BEEML"), 
       fill= c("blue", "brown", "orange"), 
       border="white", lty=NULL, bty = "n", cex=1)
text(0, 2.4, "Use the color of motif names to separate the computational algorithms used with the parameter col.leaves", cex=1.5)
```

### Supplementary Figure 2J
```{r colorsets3, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("color setting, leave background", "J")}
icgp <- ifelse(sapply(sapply(unaligned.pfms, getIC), mean) > 0.6, 
               "lightgray", "black")
plotMotifStackWithRadialPhylog(phylog=phylog, pfms=unaligned.pfms,
                            labels.leaves=leaveNames, 
                            col.leaves.bg=icgp, 
                            col.leaves.bg.alpha=.3, 
                            cleaves=.2, circle=1.1, circle.motif=1.6, 
                            clabel.leaves=.8, angle=358)
legend(-2.3, 2.4, 
       legend=c("Information Content <= 0.6", "Information Content > 0.6"), 
       fill= highlightCol(c("black", "lightgray"), alpha=.3), 
       border="white", lty=NULL, bty = "n", cex=1)
text(0, 2.4, 
     "Use the color of the background of the motif names to distinguish motifs with high and low IC with the parameter col.leaves.bg", 
     cex=1.5)
```

### Supplementary Figure 2K
```{r colorsets4, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("color setting, inner circle", "K")}
plotMotifStackWithRadialPhylog(phylog=phylog, pfms=unaligned.pfms,
                            labels.leaves=leaveNames, 
                            col.inner.label.circle=motifGroup,
                            inner.label.circle.width=0.1,
                            cleaves=.2, circle=1.1, circle.motif=1.6, 
                            clabel.leaves=.8, angle=358)
legend(1.5, 2.4, legend=levels.motifGroup[1:12], 
       fill= colors.motifGroup[1:12], 
       border="black", lty=NULL, bty = "n", ncol=2, cex=.8)
legend(1.5, -2, legend=levels.motifGroup[13:21], 
       fill= colors.motifGroup[13:21], 
       border="black", lty=NULL, bty = "n", ncol=2, cex=.8)
text(0, 2.4, 
     "Use the color of the inner ring of the motif circle to distinguish motif groups with the parameter col.inner.label.circle", 
     cex=1.5)
```

### Supplementary Figure 2L
```{r colorsets5, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("color setting, outer circle", "L")}
plotMotifStackWithRadialPhylog(phylog=phylog, pfms=unaligned.pfms,
                            labels.leaves=leaveNames, 
                            col.outer.label.circle=motifGroup,
                            outer.label.circle.width=0.1,
                            cleaves=.2, circle=1.1, circle.motif=1.6, 
                            clabel.leaves=.8, angle=358)
legend(1.5, 2.4, legend=levels.motifGroup[1:12], 
       fill= colors.motifGroup[1:12], 
       border="black", lty=NULL, bty = "n", ncol=2, cex=.8)
legend(1.5, -2, legend=levels.motifGroup[13:21], 
       fill= colors.motifGroup[13:21], 
       border="black", lty=NULL, bty = "n", ncol=2, cex=.8)
text(0, 2.4, 
     "Use the color of the outer ring of the motif circle to distinguish motif groups with parameter col.outer.label.circle", 
     cex=1.5)
```

### Supplementary Figure 2M
```{r colorsets6, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("color setting, use a combination of coloring options", "M")}
plotMotifStackWithRadialPhylog(phylog=phylog, pfms=aligned.pfms,
                               labels.leaves=leaveNames, 
                               col.bg=algorithm, col.bg.alpha=.3,
                               col.leaves.bg=icgp, 
                               col.leaves.bg.alpha=.3, 
                               cleaves=.2, circle=1.1, circle.motif=1.6, 
                               clabel.leaves=.8, angle=358)
legend(-2.3, 2.4, 
       legend=c("algorithm", "CIS-BP/DREAM5", "Uniprobe/Seed-And-Wobble", 
                "Uniprobe/BEEML", "Information Content", "<= 0.6", "> 0.6"), 
       fill= c("white", 
               highlightCol(c("blue", "brown", "orange"), alpha=.3), 
               "white", highlightCol(c("black", "lightgray"), alpha=.3)), 
       border="white", lty=NULL, bty = "n", cex=.8)

detach(motIVout)
```


## Supplementary Figure 2N-O. Compare different Column Comparison Metrics (CCM) and aligment methods

Here we illustrate how to set the CCM and alignment method using MotIV or MatAlign, and that different choices of methods might affect the subsequent analysis and intepretation in motifStack.

When clustering using MovIV, Pearson Correlation Coefficient (PCC) or
Average Log Likelihood Ratio (ALLR) is used as the CCM, and Smith-Waterman Ungapped (SWU) or Needleman-Wunsch (NW) is used as the alignment method. When clustering the motifs using MatAlign, ALLR and SWU are used.

To run the MatAlign examples, phylip (http://evolution.genetics.washington.edu/phylip/progs.data.dist.html) and MatAlign (http://stormo.wustl.edu/MatAlign/) need to be installed first.

### Supplementary Figure 2N
```{r MotIV, fig.width=4, fig.height=4, fig.cap=fn("MotIV with different CCM and alignment methods", "N")}

sta <- mapply(function(cc, align){
    motIVout <- getMotIVOut(pfms, cc, align)
    attach(motIVout)
    plotMotifStackWithRadialPhylog(phylog=phylog, pfms=aligned.pfms,
                               labels.leaves=leaveNames, 
                               col.bg=algorithm, col.bg.alpha=.3, 
                               col.inner.label.circle=motifGroup,
                               inner.label.circle.width=0.1,
                               cleaves=.2, circle=1.1, circle.motif=1.6, 
                               clabel.leaves=.3, angle=358)

    legend(-2.3, 2.4, 
           legend=c("CIS-BP/DREAM5", "Uniprobe/Seed-And-Wobble", 
                    "Uniprobe/BEEML"), 
           fill= highlightCol(c("blue", "brown", "orange"), alpha=.3), 
           border="white", lty=NULL, bty = "n", cex=.5)
    text(0, 2.3, label=paste("cc=", cc, "; align=", align), cex=1.5)
    cnt <- rle(motifGroup)
    cnt <- split(algorithm, rep(1:length(cnt$lengths), cnt$lengths))
    cnt <- table(sapply(cnt, function(.ele) length(unique(.ele))))
    cnt.1 <- vector("integer", 3)
    names(cnt.1) <- 1:3
    cnt.1[names(cnt)] <- cnt
    cnt.1["1"] <- (cnt.1["1"]+cnt.1["2"]*2+cnt.1["3"]*3)/3 - cnt.1["2"] - cnt.1["3"]
    text(0, -2.3, 
         label=paste(names(cnt.1), cnt.1, sep=":", collapse="; "), cex=1.5)
    detach(motIVout)
}, c("PCC", "PCC", "ALLR", "ALLR"), c("NW", "SWU", "NW", "SWU"))
```

The number (1:xx; 2:yy; 3:zz) on the bottom of the figure 2O and 2P represents the number of motifs identified by different number of motif comparison and clustering algorithms. 1:xx means that xx number of motifs are identified by one algorithm; 2:yy means that yy number of motifs are identified by two different algorithms; 3:zz means that zz number of motifs are identified by three different algorithms.

### Supplementary Figure 2O
```{r MatAlign, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("UPGMA tree by matAlign+PHYLIP", "O")}
##read newick tree. Alignment is done by MatAlign
##and the newick tree is generated by Neighbor, which is a part of phylip
outpath <- "output"
matalign_path <- "./app/matalign-v4a"
neighbor_path <- "./app/neighbor.app/Contents/MacOS/neighbor"
system(paste("perl MatAlign2tree.pl --in . --pcmpath", pcmpath, 
             "--out", outpath,
             "--matalign", matalign_path, 
             "--neighbor", neighbor_path, 
             "--tree","UPGMA"))
newickstrUPGMA <- readLines(con=file.path(outpath, "NJ.matalign.distMX.nwk"))
##convert to phylog object
phylogUPGMAmatAlign <- newick2phylog(newickstrUPGMA, FALSE)

##get the leaves of phylog to reorder the pfms
leaveNames <- names(phylogUPGMAmatAlign$leaves)
this_motifs <- pfms[leaveNames]

## data source
dataSource <- factor(grepl("_M", leaveNames))
levels(dataSource) <- c("yellow", "blue") ##c("Uniprobe", "CIS-BP")
dataSource <- as.character(dataSource)
## algorithm
algorithm <- factor((!grepl("_M", leaveNames)) + grepl("_bml", leaveNames))
levels(algorithm) <- c("blue", "brown", "orange") ##("DREAM5", "Seed-And-Wobble", "BEEML")
algorithm <- as.character(algorithm)
## motifs from same PBM data
motifGroup <- factor(gsub("(.*?)_.*$", "\\1", leaveNames))
levels.motifGroup <- levels(motifGroup)
levels(motifGroup) <- pairColor[1:length(levels(motifGroup))]
colors.motifGroup <- levels(motifGroup)
motifGroup <- as.character(motifGroup)

## draw the motifs
plotMotifStackWithRadialPhylog(phylog=phylogUPGMAmatAlign, 
                               pfms=DNAmotifAlignment(this_motifs),
                               labels.leaves=leaveNames, 
                               col.bg=algorithm, 
                               col.bg.alpha=.3, 
                               col.inner.label.circle=motifGroup, 
                               inner.label.circle.width=.1,
                               cleaves=.2, circle=1.1, 
                               circle.motif=1.6, 
                               clabel.leaves=.6, angle=358)

legend(1.5, 2.4, legend=levels.motifGroup[1:12], 
       fill= colors.motifGroup[1:12], 
       border="black", lty=NULL, bty = "n", ncol=2, cex=.8)
legend(1.5, -2, legend=levels.motifGroup[13:21], 
       fill= colors.motifGroup[13:21], 
       border="black", lty=NULL, bty = "n", ncol=2, cex=.8)
legend(-2.35, 2.4, 
       legend=c("CIS-BP/DREAM5", "Uniprobe/Seed-And-Wobble", "Uniprobe/BEEML"),
       fill= highlightCol(c("blue", "brown", "orange"), alpha=.3), 
       border="white", lty=NULL, bty = "n", cex=.8)
cnt <- rle(motifGroup)
cnt <- split(algorithm, rep(1:length(cnt$lengths), cnt$lengths))
cnt <- table(sapply(cnt, function(.ele) length(unique(.ele))))
cnt.1 <- vector("integer", 3)
names(cnt.1) <- 1:3
cnt.1[names(cnt)] <- cnt
cnt.1["1"] <- (cnt.1["1"]+cnt.1["2"]*2+cnt.1["3"]*3)/3 - cnt.1["2"] - cnt.1["3"]
text(0, -2.3, label=paste(names(cnt.1), cnt.1, sep=":", collapse="; "), cex=1.5)
```


## Supplementary Figure 2P. Different distance resolution between MotIV and MatAlign even when using the same Column Comparison Matrix and alignment method

```{r revolution.1, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("MotIV(ALLR and SWU) as the alignment method", "P.a")}
pcmpath <- "pcmsDatasetDM"
pcms <- readPCM(pcmpath)
pfms<-lapply(pcms,pcm2pfm)
motIVout <- getMotIVOut(pfms, "ALLR", "SWU")
plotMotifStackWithRadialPhylog(phylog=motIVout$phylog, 
                               pfms=motIVout$aligned.pfms, 
                               labels.leaves=motIVout$leaveNames, 
                               cleaves=.2, circle=1.2, circle.motif=1.6, 
                               clabel.leaves=1, 
                               motifScale="logarithmic", 
                               angle=358, 
                               plotIndex=FALSE)
text(0, 2.4, label="motIV: cc=ALLR; align=SWU", cex=1.5)
```
```{r revolution.2, fig.width=12, fig.height=12, dpi=72, fig.cap=fn("MatAlign (ALLR and SWU) as the alignment method", "P.b")}
## function to read example data
getMatAlignOut <- function(pcmpath, outpath="output", 
                          groupDistance=NA, trim=0.2){
    pcms <- readPCM(pcmpath)
    pfms<-lapply(pcms,pcm2pfm)
    matalign_path <- "./app/matalign-v4a"
    neighbor_path <- "./app/neighbor.app/Contents/MacOS/neighbor"
    system(paste("perl MatAlign2tree.pl --in . --pcmpath", pcmpath, 
                 "--out", outpath,
                 "--matalign", matalign_path, 
                 "--neighbor", neighbor_path, 
                 "--tree","UPGMA"))
    newickstrUPGMA <- 
        readLines(con=file.path(outpath, "NJ.matalign.distMX.nwk"))
    phylog <- newick2phylog(newickstrUPGMA, FALSE)
    leaves <- names(phylog$leaves)
    motifs <- pfms[leaves]
    if(!is.na(groupDistance)){
        motifSig <- 
            motifSignature(motifs, phylog, 
                           groupDistance=groupDistance, 
                           min.freq=1, trim=trim)
        sig <- signatures(motifSig)
        gpCol <- sigColor(motifSig)
    }else{
        motifSig <- NA
        sig <- NA
        gpCol <- NA
    }
    
    return(list(phylog=phylog, sig=sig, gpCol=gpCol, 
                motifs=DNAmotifAlignment(motifs), 
                leaves=leaves, 
                unaligned.pfms=motifs))
}

matAlignOut <- getMatAlignOut(pcmpath)
plotMotifStackWithRadialPhylog(phylog=matAlignOut$phylog, 
                               pfms=matAlignOut$motifs, 
                               labels.leaves=matAlignOut$leaves, 
                               cleaves=.2, circle=1.2, circle.motif=1.6, 
                               clabel.leaves=1, motifScale="logarithmic", 
                               angle=358, plotIndex=FALSE)
text(0, 2.4, label="MatAlign", cex=1.5)
```

```{r}
sessionInfo()
```